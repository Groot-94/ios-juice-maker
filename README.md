# ⛺️iOS 커리어 스타터 캠프

## 목차
- [쥬스 메이커 프로젝트 ](#️-쥬스-메이커-프로젝트)
    - [UML](#uml)
    - [실행 영상](#-실행-화면)
- [구현 내용](#로직구현--구현-내용)
   - [로직 구현](#로직구현--구현-내용 )
   - [Step1](#고민한점---step1)
     - [고민했던점](#고민한점---step1 )
     - [배운개념](#배운-개념)
- [피드백 수정](#피드백-받아서-수정하고-개선-한점)

</br>
</br>


## ⛺️ 쥬스 메이커 프로젝트 
🗓 기간 : 2022.02.21 ~ 2022.02.24(4d)</br>
🗓 팀원 : [로이](https://github.com/Roy-wonji), [Eddy](https://github.com/kimkyunghun3)</br>
🗓 리뷰어 : [도미닉](https://github.com/AppleCEO)</br>
📝 설명 : 맛있는 주스를 만들고, 재고 관리까지 해주는 app  (console app)</br>
</br>


 

</br>

### UMl

![](https://i.imgur.com/4EOUmDQ.png)

###  실행 화면
</br>



</br>

### 로직구현 & 구현 내용 
- `JuiceMakerError`  에러타입  enum 구현
- `consumeFruit`  과일의 수를 세는 함수 구현 
- `JuiceTypes` 쥬스의 과일의 타입을 구현
- `recipe`  쥬스 레시피 switch로  각 레시피 별로 과일 수량 구현 
- `makeJuice` 레시피 수량을 확인 하는 함수 


</br>




  

### 고민한점  & Step1

1. 역시나  네이밍은  항상  어렵고  힘드네요 .. ㅠㅠ🤣🤣
```swift=
 result를 안쓰고 한 경우 
 func makeJuice(fruitJuice: FruitsTypes) {
        let recipe = fruitJuice.recipe
        do  {
            try fruitStore.countFruit(recipe: recipe)
        } catch JuiceMakerError.outOfStock {
            print("재고가 없습니다")
        } catch {}
    }

```
</br>

result를 쓰고 한 경우인데  아직은 result에 대한 공부가 부족해서 
do catch문으로 코드를 구현해서 pr을 요청드립니다

```swift=
 func make(fruitJuice: Int) -> Result<Bool, JuiceMakerError>{
    
        guard fruitJuice > 10 else {
            return .failure(.outOfStock)
        }
        return .success(true)
```

> 보통 result 를 안 쓰고 진행하는 것 같습니다. 에러가 표시되야하면 throw 해서 상위 함수에서 에러 처리를 한다던지 해서요. 이렇게 하면 result를 따로 사용하지 않아도 괜찮을 것 같습니다.
> 
</br>

2. 처음 UML 작성처럼 기능을 클래스 단위로 분리해서 코드를 구현해볼까 고민해봤습니다. 그래서 가장 슈퍼클래스에서 이들을 상속받아서 하려고 했으나, 찾아보았더니 다중상속을 swift는 지원을 하지 않는 것으로 알게 되었습니다. 그래서 기능을 다른 클래스에서 상속받아서 연달아 사용하는 방식(마치 함수들을 연결짓기 위해 매개변수를 활용하는 방식)을 생각했는데, 이렇게 되면 초기화 함수 같은 것을 구현했을 떄 매번 사용할 떄 불편할 뿐만 아니라 이렇게 기능단위로 클래스 구분이 맞는가 의심이 되었습니다. 작은 단위로 기능을 구현하는 것도 좋지만 한 클래스 안에 속할 수 있는 기능은 클래스 하나로 묶어서 하는 것이 저는 더 맞는 구현 방향이라고 생각하는데 이에 대한 조언을 듣고 싶습니다.
> 하나의 클래스에서 너무 많은 동작을 하면 읽기도 힘들고 객체지향적이지 않게 됩니다. 각자 역할을 나눠서 여러 객체가 상호작용하면서 동작이 진행되는 것이 더 좋다고 생각합니다. 물론 기능이 연관되 있으면 하나의 클래스에서 최대한 구현하는 것도 괜찮겠죠!
> 
3. UML에서 저희가 상속을 사용하지 않고 예를 들어 구조체로 구현한 것을 인스턴스하여 사용하거나 enum을 하나의 딕셔너리를 초기화할 떄 사용하는 식으로 했는데 이런 경우에는 어떻게 연결관계를 해야할지 고민이 되었습니다. 단순히 연관이 있다고 해서 현재에는 선을 통해서 표현했는데, UML Class diagram 같은 경우에는 클래스의 상속 등과 같은 객체적 연관관계와 이에 따른 화살표 모양이 존재하는데 구조체같은 경우에는 이처럼 선으로만해서 이를 사용하고 있다고 봐도 될까요? 상속이 아닌 인스턴스 만드는 것이라 저는 그부분이 맞다고 생각이 들었었습니다.

> 클래스와 구조체는 같은 객체라서 클래스와 거의 같게 그릴 수 있을 것 같습니다. 상속같은 부분은 구조체에서는 못하니까 못그리는게 맞겠지만요~

### 브랜치 전략 
- main: 완성된 프로젝트를 보관하는 브랜치
- develop: pr를 받고 완성된 코드를 병합하는 브랜치
- step1,2,3: 각 스텝의 요구사항을 구현하는 / 평소 코드를 작성하는 브랜치

 ![](https://i.imgur.com/RyPTGCQ.jpg)
 
### 학습 키워드
- CaseIterable
- enum - associated value
- git flow
- MVC
- 초기화
- do try catch 
- class & struct 
- 저장 프로퍼티

### 배운 개념 
- 에러 메세지를 출력할 때에는 다른 에러가 있을 수 있다는 가능성을 배제하면 안되고 모든 경우의 수에 대한 처리와 에러 메시지를 통해 구분하여 에러가 났을 때 개발자가 바로 확인가능하도록 해야한다.
- 코딩 컨벤션을 정할 때  함수와 함수사이에 띄어쓰기 등과 같이 코드의 컨벤션으로 코드의 가독성을 증진 시키고 읽기 좋은 코드룰 작성 할수있다. 
- class, struct의 가장 큰 차이점은 상속가능여부에 있다. 또한 모든 기능별로 클래스를 구분하여 사용하게 되면 무분별한 상속이 이루어지기 때문에 오히려 가독성을 해칠 수 있다. 그러므로 클래스에 속하는 연관된 기능은 하나의 클래스로 묶는 것이 가독성을 높이고 구현의 편의성도 제공한다.
- git flow를 사용함으로써 메인에서 생기는 에러를 미리 수정하여 메인 프로젝트와 거리를 유지할 수 있다. 또한 브랜치별 구현을 통해 가독성이 높아지고 분업화된 협업이 가능해진다.
- CaseIterable는 모든 case 값들에 컬렉션을 제공하는 타입으로 일반적으로 enum으로 각 케이스 별로 관리 하는것 보다  한 꺼번에 enum의 값을  변경해줄수 있어서 사용하기가 편리 했다.
  
### 피드백 받아서 수정하고 개선 한점
